<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Diff Viewer</title>
    <!-- Google "Inter" font family -->
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Inter", sans-serif;
        display: flex;
        margin: 0; /* Simplify bounds so the parent can determine the correct iFrame height. */
        padding: 0;
        overflow: hidden; /* Code can be long and wide, causing scroll-within-scroll. */
      }

      .container {
        padding: 1.5rem;
        background-color: #fff;
      }

      h2 {
        font-size: 1.5rem;
        font-weight: 700;
        color: #1f2937;
        margin-bottom: 1rem;
        text-align: center;
      }

      .diff-output-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1rem;
        background-color: #f8fafc;
        border: 1px solid #e2e8f0;
        border-radius: 0.75rem;
        box-shadow:
          0 4px 6px -1px rgba(0, 0, 0, 0.1),
          0 2px 4px -1px rgba(0, 0, 0, 0.06);
        padding: 1.5rem;
        font-size: 0.875rem;
        line-height: 1.5;
      }

      .diff-original-column {
        padding: 0.5rem;
        border-right: 1px solid #cbd5e1;
        min-height: 150px;
      }

      .diff-modified-column {
        padding: 0.5rem;
        min-height: 150px;
      }

      .diff-line {
        display: block;
        min-height: 1.5em;
        padding: 0 0.25rem;
        white-space: pre-wrap;
        word-break: break-word;
      }

      .diff-added {
        background-color: #d1fae5;
        color: #065f46;
      }
      .diff-removed {
        background-color: #fee2e2;
        color: #991b1b;
        text-decoration: line-through;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="diff-output-container">
        <div class="diff-original-column">
          <h2 id="original-title">Before</h2>
          <pre id="originalDiffOutput"></pre>
        </div>
        <div class="diff-modified-column">
          <h2 id="modified-title">After</h2>
          <pre id="modifiedDiffOutput"></pre>
        </div>
      </div>
    </div>
    <script>
      // Function to dynamically load the jsdiff library.
      function loadJsDiff() {
        const script = document.createElement("script");
        script.src = "https://cdnjs.cloudflare.com/ajax/libs/jsdiff/8.0.2/diff.min.js";
        script.integrity =
          "sha512-8pp155siHVmN5FYcqWNSFYn8Efr61/7mfg/F15auw8MCL3kvINbNT7gT8LldYPq3i/GkSADZd4IcUXPBoPP8gA==";
        script.crossOrigin = "anonymous";
        script.referrerPolicy = "no-referrer";
        script.onload = populateDiffs; // Call populateDiffs after the script is loaded
        script.onerror = () => {
          console.error("Error: Failed to load jsdiff library.");
          const originalDiffOutput = document.getElementById("originalDiffOutput");
          if (originalDiffOutput) {
            originalDiffOutput.innerHTML =
              '<p style="color: #dc2626; text-align: center; padding: 2rem;">Error: Diff library failed to load. Please try refreshing the page or check your internet connection.</p>';
          }
          const modifiedDiffOutput = document.getElementById("modifiedDiffOutput");
          if (modifiedDiffOutput) {
            modifiedDiffOutput.innerHTML = "";
          }
        };
        document.head.appendChild(script);
      }

      function populateDiffs() {
        const originalDiffOutput = document.getElementById("originalDiffOutput");
        const modifiedDiffOutput = document.getElementById("modifiedDiffOutput");
        const originalTitle = document.getElementById("original-title");
        const modifiedTitle = document.getElementById("modified-title");

        // Check if jsdiff library is loaded.
        if (typeof Diff === "undefined") {
          console.error("Error: jsdiff library (Diff) is not loaded or defined.");
          // This case should ideally be caught by script.onerror, but keeping as a fallback.
          if (originalDiffOutput) {
            originalDiffOutput.innerHTML =
              '<p style="color: #dc2626; text-align: center; padding: 2rem;">Error: Diff library failed to load. Please try refreshing the page or check your internet connection.</p>';
          }
          if (modifiedDiffOutput) {
            modifiedDiffOutput.innerHTML = ""; // Clear modified output if error
          }
          return; // Exit since jsdiff is not loaded.
        }

        // The injected codes to display.
        const codes = JSON.parse(`{
  "old_index": 802.0,
  "old_code": "# TODO: Implement the \`quadrature()\` function to numerically evaluate integrals.\\n\\nimport math\\nfrom typing import Any, Callable, Tuple\\nimport numpy as np\\nimport scipy.integrate\\nimport scipy.optimize\\n\\ndef quadrature(\\n    integrand: Callable[float, float],\\n    lower_limit: float,\\n    upper_limit: float,\\n) -> Tuple[float, float]:\\n    \\"\\"\\"\\n    Estimate the numeric value of the definite integral, especially\\n    when scipy.integrate.quad() fails to converge or returns a large error\\n    estimate or NaN.\\n    \\"\\"\\"\\n\\n    # Handle trivial case where limits are the same\\n    if lower_limit == upper_limit:\\n        return 0.0, 0.0\\n\\n    # Helper for robust quad calls with custom tolerances and limits\\n    def _robust_quad_call(func, a, b, limit_val, epsabs_val, epsrel_val):\\n        \\"\\"\\"\\n        Calls scipy.integrate.quad with specified parameters and performs strict checks\\n        for reliability of the returned value and error estimate.\\n        \\"\\"\\"\\n        try:\\n            val, err = scipy.integrate.quad(\\n                func, a, b,\\n                limit=limit_val,\\n                epsabs=epsabs_val,\\n                epsrel=epsrel_val\\n            )\\n            \\n            # Critical check 1: Detect NaN or Inf results for both value and error.\\n            if np.isnan(val) or np.isinf(val) or \\\\\\n               np.isnan(err) or np.isinf(err):\\n                raise ValueError(\\"Scipy quad returned NaN or Inf result.\\")\\n            \\n            # Critical check 2: Verify if the requested precision was met.\\n            # \`quad\`'s documentation states it tries to achieve \`err <= max(epsabs, abs(val) * epsrel)\`.\\n            requested_tolerance_target = max(epsabs_val, abs(val) * epsrel_val)\\n            # A small factor (1 + 1e-9) is used to account for floating-point precision in comparison.\\n            if err > requested_tolerance_target * (1 + 1e-9):\\n                raise ValueError(f\\"Scipy quad failed to meet requested precision: returned_err={err:.2e}, requested_tol={requested_tolerance_target:.2e}.\\")\\n            \\n            return val, err\\n        except Exception as e:\\n            # Catch any exception from quad itself or from our checks.\\n            raise ValueError(f\\"Scipy quad call failed or its result deemed unreliable: {e}\\")\\n\\n    # --- Step 1: Tiered Attempts with scipy.integrate.quad() on the original interval ---\\n    # These attempts use increasingly stringent parameters for general convergence.\\n    # The \`limit\` parameter controls the maximum number of subintervals.\\n    quad_attempts = [\\n        {'limit': 500000, 'epsabs': 1e-10, 'epsrel': 1e-10},\\n        {'limit': 1000000, 'epsabs': 1e-12, 'epsrel': 1e-12},\\n        {'limit': 2000000, 'epsabs': 1e-13, 'epsrel': 1e-13}\\n    ]\\n\\n    for attempt_params in quad_attempts:\\n        try:\\n            answer, error_estimate = _robust_quad_call(\\n                integrand, lower_limit, upper_limit,\\n                limit_val=attempt_params['limit'],\\n                epsabs_val=attempt_params['epsabs'],\\n                epsrel_val=attempt_params['epsrel']\\n            )\\n            return answer, error_estimate\\n        except ValueError:\\n            # If _robust_quad_call raises a ValueError, it means this attempt failed.\\n            # We fall through to the next attempt or a more specialized method.\\n            pass\\n\\n    # --- Step 2: Handle Infinite Limits via Transformations or Splitting ---\\n    # If all direct quad attempts failed, we now apply transformations for infinite domains.\\n    \\n    # Case: (-inf, inf)\\n    if lower_limit == -np.inf and upper_limit == np.inf:\\n        # Split into two infinite integrals: (-inf, 0.0] and [0.0, inf).\\n        try:\\n            # Recursively call \`quadrature\` for the two sub-integrals.\\n            val1, err1 = quadrature(integrand, -np.inf, 0.0)\\n            val2, err2 = quadrature(integrand, 0.0, np.inf)\\n            \\n            # Explicitly check for problematic results from sub-integrals.\\n            if np.isnan(val1) or np.isinf(val1) or np.isnan(val2) or np.isinf(val2):\\n                return np.nan, np.inf\\n            \\n            # Combine errors in quadrature: sqrt(err1^2 + err2^2)\\n            total_err_combined = math.sqrt(err1**2 + err2**2)\\n            \\n            return val1 + val2, total_err_combined\\n        except Exception: # Catch any exceptions during the splitting or summation.\\n            return np.nan, np.inf\\n\\n    # Case: (-inf, b] where b is finite\\n    elif lower_limit == -np.inf and upper_limit != np.inf: \\n        # Transformation: let x = -t. Then dx = -dt.\\n        # Original limits: x -> -inf (t -> inf); x -> upper_limit (t -> -upper_limit).\\n        # The integral becomes: Integral from inf to -upper_limit of f(-t) (-dt)\\n        # which simplifies to: Integral from -upper_limit to inf of f(-t) dt.\\n        def transformed_integrand_neg_inf(t):\\n            return integrand(-t) \\n\\n        # Recursively call \`quadrature\` with the transformed integrand and new limits.\\n        return quadrature(transformed_integrand_neg_inf, -upper_limit, np.inf)\\n    \\n    # Case: [a, b] where a and b are finite, and all tiered quad attempts failed.\\n    # If \`scipy.integrate.quad\` (even with aggressive parameters) failed to converge on a finite interval,\\n    # it strongly suggests a pathological function or a severe singularity.\\n    # In such scenarios, returning NaN with an infinite error is the most appropriate indication of failure.\\n    elif upper_limit != np.inf: \\n        return np.nan, np.inf\\n\\n    # --- Step 3: Specialized Method for [a, inf) using Segment Summation & Euler Acceleration ---\\n    # This part is reached only if previous \`scipy.integrate.quad\` attempts (including for transformed integrals) failed.\\n    # It applies specifically to integrals of the form [lower_limit, inf).\\n\\n    current_segment_start = float(lower_limit)\\n    \\n    # Segment length will grow exponentially to efficiently cover the infinite domain.\\n    # \`initial_segment_base_length\` is critical and the candidates are chosen to try to align with oscillation periods.\\n    initial_segment_length_candidates = [math.pi / 2.0, 1.0, 0.5, 0.1, 0.01, 0.001] \\n    segment_growth_factor = 1.2 # Factor by which subsequent segments grow in length.\\n    \\n    segment_integrals = [] # List to store the numerical value of each integrated segment.\\n    total_quad_error_sq = 0.0 # New: Accumulated *squared* quadrature error from all segments.\\n    \\n    max_segments_to_compute = 150000 # Increased maximum segments to allow for very slow convergence.\\n    min_segments_for_euler = 30     # Minimum segments required for reliable Euler acceleration (increased for robustness).\\n    target_consecutive_converged = 10 # Number of consecutive stable Euler diagonal values (increased for higher confidence).\\n\\n    # Tolerances for Euler method convergence and individual segment integration precision.\\n    euler_abs_tol = 1e-10\\n    euler_rel_tol = 1e-8\\n    segment_integration_tol = 1e-8 # Tolerance passed to \`_robust_quad_call\` for each segment.\\n    \\n    # A small absolute error floor to ensure errors are not zero when they should represent uncertainty.\\n    MIN_ERROR_THRESHOLD = 1e-15 \\n\\n    # Integrate the first segment: Iterate through candidates for initial length.\\n    seg_val, seg_err = np.nan, np.inf # Initialize with problematic values.\\n    found_good_first_segment = False\\n    for try_length in initial_segment_length_candidates:\\n        seg_end = current_segment_start + try_length\\n        # Ensure the segment is not numerically tiny or invalid.\\n        if seg_end <= current_segment_start + 1e-12: \\n            continue\\n        try:\\n            # Use \`_robust_quad_call\` for the first segment to ensure high quality integration.\\n            # We use a higher \`limit_val\` for this critical first segment.\\n            seg_val, seg_err = _robust_quad_call(\\n                integrand, current_segment_start, seg_end,\\n                limit_val=2000000,\\n                epsabs_val=segment_integration_tol, epsrel_val=segment_integration_tol\\n            )\\n            found_good_first_segment = True\\n            total_quad_error_sq += seg_err ** 2\\n            break\\n        except ValueError:\\n            pass\\n    \\n    if not found_good_first_segment:\\n        # If no initial segment length produced a reliable result, the integral is likely intractable by this method.\\n        return np.nan, np.inf \\n\\n    # Add the first successful segment's value to our list.\\n    segment_integrals.append(seg_val)\\n    current_segment_start = seg_end\\n    \\n    # Store previous segment value for convergence and divergence checks.\\n    prev_seg_val = seg_val \\n\\n    # Counters for heuristic checks on series behavior.\\n    consistent_sign_count = 0 \\n    consecutive_decay_count = 0 \\n    \\n    # Main loop for computing subsequent segments.\\n    for i in range(1, max_segments_to_compute): \\n        seg_start = current_segment_start\\n        seg_end = current_segment_start + initial_segment_length_candidates[0] * (segment_growth_factor ** i) \\n\\n        # Prevent issues with extremely small intervals due to floating point.\\n        if seg_end - seg_start < 1e-12: \\n            break\\n\\n        try:\\n            # Integrate each segment.\\n            seg_val, seg_err = _robust_quad_call(\\n                integrand, seg_start, seg_end,\\n                limit_val=1000000,\\n                epsabs_val=segment_integration_tol, epsrel_val=segment_integration_tol\\n            )\\n            total_quad_error_sq += seg_err ** 2\\n        except ValueError: \\n            current_sum_so_far = np.sum(segment_integrals) if segment_integrals else 0.0\\n            error_on_segment_failure_component = np.sum(np.abs(segment_integrals[max(0, len(segment_integrals) - min(15, len(segment_integrals))):]))\\n            \\n            final_error = math.sqrt(error_on_segment_failure_component**2 + total_quad_error_sq)\\n            final_error = max(final_error, MIN_ERROR_THRESHOLD)\\n            \\n            return current_sum_so_far, final_error \\n\\n        segment_integrals.append(seg_val)\\n        current_segment_start = seg_end\\n\\n        # --- Early stopping and Euler suitability checks based on series behavior ---\\n        \\n        # Check 1: Consistent non-alternating signs. Euler works best for alternating series.\\n        if abs(seg_val) > euler_abs_tol * 0.01:\\n            if seg_val * prev_seg_val >= 0: \\n                consistent_sign_count += 1\\n            else:\\n                consistent_sign_count = 0 \\n        else:\\n            consistent_sign_count = 0 \\n        \\n        if consistent_sign_count >= 15 and i >= min_segments_for_euler:\\n            current_sum_so_far = np.sum(segment_integrals) if segment_integrals else 0.0\\n            error_on_non_alternating_component = np.sum(np.abs(segment_integrals[max(0, len(segment_integrals) - min(15, len(segment_integrals))):]))\\n            \\n            final_error = math.sqrt(error_on_non_alternating_component**2 + total_quad_error_sq)\\n            final_error = max(final_error, MIN_ERROR_THRESHOLD)\\n            \\n            return current_sum_so_far, final_error \\n\\n        # Check 2: Rapid decay of terms. If terms quickly become very small, the series might already be converging.\\n        current_sum = np.sum(segment_integrals)\\n        if abs(seg_val) < (euler_abs_tol * 0.001) and \\\\\\n           (abs(seg_val) < (euler_rel_tol * 0.001 * abs(current_sum) if current_sum != 0 else euler_abs_tol * 0.001)): \\n            consecutive_decay_count += 1\\n            if consecutive_decay_count >= 20:\\n                break\\n        else:\\n            consecutive_decay_count = 0\\n        \\n        # Check 3: Strong divergence in terms. If terms are growing rapidly, the integral likely diverges.\\n        if i >= min_segments_for_euler and \\\\\\n           abs(prev_seg_val) > euler_abs_tol * 0.01 and \\\\\\n           abs(seg_val) > abs(prev_seg_val) * 100:\\n            current_sum_so_far = np.sum(segment_integrals) if segment_integrals else 0.0\\n            error_on_divergence_component = np.sum(np.abs(segment_integrals[max(0, len(segment_integrals) - min(15, len(segment_integrals))):]))\\n            \\n            final_error = math.sqrt(error_on_divergence_component**2 + total_quad_error_sq)\\n            final_error = max(final_error, MIN_ERROR_THRESHOLD)\\n            \\n            return current_sum_so_far, final_error \\n\\n        prev_seg_val = seg_val\\n\\n    # Sum of segments before Euler acceleration. This acts as a fallback if Euler transformation fails.\\n    initial_sum_segments = np.sum(segment_integrals) if segment_integrals else 0.0\\n    \\n    N_segments = len(segment_integrals)\\n    \\n    # If not enough terms for Euler acceleration, return the direct sum with a conservative error.\\n    if N_segments < min_segments_for_euler:\\n        if N_segments > 0: \\n            error_estimate_no_euler_component = np.sum(np.abs(segment_integrals[max(0, N_segments - min(15, N_segments)):])) \\n            \\n            final_error = math.sqrt(error_estimate_no_euler_component**2 + total_quad_error_sq)\\n            final_error = max(final_error, MIN_ERROR_THRESHOLD)\\n            \\n            return initial_sum_segments, final_error \\n        return initial_sum_segments, np.inf\\n\\n    # Apply Euler's Transformation (series acceleration) to the collected segment integrals.\\n    euler_current_sequence = np.array(segment_integrals, dtype=float)\\n    euler_diagonal_values = [euler_current_sequence[0]] \\n    consecutive_converged_count = 0 \\n\\n    try:\\n        max_euler_levels = N_segments - 1\\n\\n        for m in range(max_euler_levels): \\n            if len(euler_current_sequence) < 2:\\n                break\\n            \\n            new_euler_sequence_array = (euler_current_sequence[:-1] + euler_current_sequence[1:]) / 2.0\\n            euler_current_sequence = new_euler_sequence_array\\n            \\n            if len(euler_current_sequence) == 0:\\n                break\\n\\n            current_euler_val = euler_current_sequence[0] \\n            euler_diagonal_values.append(current_euler_val) \\n            \\n            # Check for convergence in the Euler diagonal values.\\n            if m > 0 and len(euler_diagonal_values) >= 2:\\n                prev_euler_val = euler_diagonal_values[-2]\\n                diff = abs(current_euler_val - prev_euler_val)\\n                \\n                is_relative_converged = (abs(current_euler_val) > euler_abs_tol) and \\\\\\n                                         (diff < euler_rel_tol * abs(current_euler_val))\\n                is_absolute_converged = (abs(current_euler_val) <= euler_abs_tol) and \\\\\\n                                         (diff < euler_abs_tol * 0.1) \\n                \\n                if is_relative_converged or is_absolute_converged:\\n                    consecutive_converged_count += 1\\n                else:\\n                    consecutive_converged_count = 0 \\n                \\n                if consecutive_converged_count >= target_consecutive_converged:\\n                    break \\n                \\n                # Check for strong divergence in the Euler diagonal.\\n                if m > 2 and abs(prev_euler_val) > euler_abs_tol * 0.01 and \\\\\\n                   abs(current_euler_val) > abs(prev_euler_val) * 100: \\n                    error_on_euler_divergence_component = np.sum(np.abs(segment_integrals[max(0, N_segments - min(15, N_segments)):]))\\n                    \\n                    final_error = math.sqrt(error_on_euler_divergence_component**2 + total_quad_error_sq)\\n                    final_error = max(final_error, MIN_ERROR_THRESHOLD)\\n                    \\n                    return initial_sum_segments, final_error\\n\\n    except Exception:\\n        error_on_euler_exception_component = np.sum(np.abs(segment_integrals[max(0, N_segments - min(15, N_segments)):]))\\n        \\n        final_error = math.sqrt(error_on_euler_exception_component**2 + total_quad_error_sq)\\n        final_error = max(final_error, MIN_ERROR_THRESHOLD)\\n        \\n        return initial_sum_segments, final_error\\n\\n    # The final answer is the last value obtained in the Euler diagonal sequence.\\n    final_answer = euler_diagonal_values[-1] if len(euler_diagonal_values) > 0 else initial_sum_segments\\n    \\n    # Calculate the error estimate for the Euler transformed result.\\n    euler_error_component = np.inf \\n\\n    if len(euler_diagonal_values) >= 2:\\n        last_diff_euler = abs(euler_diagonal_values[-1] - euler_diagonal_values[-2])\\n        \\n        if consecutive_converged_count >= target_consecutive_converged:\\n            euler_error_component = max(last_diff_euler, \\n                                 euler_rel_tol * abs(final_answer), \\n                                 euler_abs_tol, MIN_ERROR_THRESHOLD) \\n        else:\\n            euler_error_component = max(last_diff_euler * 5, \\n                                 euler_rel_tol * abs(final_answer) * 5, \\n                                 euler_abs_tol * 5, MIN_ERROR_THRESHOLD) \\n    else: \\n        euler_error_component = np.sum(np.abs(segment_integrals[max(0, N_segments - min(15, N_segments)):]))\\n        euler_error_component = max(euler_error_component, \\n                               abs(initial_sum_segments) * euler_rel_tol * 10, \\n                               euler_abs_tol * 10, MIN_ERROR_THRESHOLD)\\n\\n    final_error_estimate = math.sqrt(euler_error_component**2 + total_quad_error_sq)\\n    final_error_estimate = max(final_error_estimate, MIN_ERROR_THRESHOLD)\\n\\n    if np.isnan(final_answer) or np.isinf(final_answer):\\n        return np.nan, np.inf\\n\\n    if np.isnan(final_error_estimate) or np.isinf(final_error_estimate):\\n        return final_answer, np.inf\\n\\n    return final_answer, final_error_estimate",
  "new_index": 825,
  "new_code": "import math\\nfrom typing import Any, Callable, Tuple\\nimport numpy as np\\nimport scipy.integrate\\nimport scipy.optimize\\n\\ndef _robust_quad_call(func, a, b, limit_val, epsabs_val, epsrel_val, max_quad_attempts=3):\\n    \\"\\"\\"\\n    Calls scipy.integrate.quad with specified parameters and performs strict checks\\n    for reliability of the returned value and error estimate.\\n    Retries with tighter tolerances if initial calls fail or results are unreliable.\\n    \\"\\"\\"\\n    # Tiered tolerance settings for internal retries within _robust_quad_call\\n    attempt_tolerances = [\\n        {'epsabs': epsabs_val, 'epsrel': epsrel_val},\\n        {'epsabs': epsabs_val * 0.1, 'epsrel': epsrel_val * 0.1},\\n        {'epsabs': epsabs_val * 0.01, 'epsrel': epsrel_val * 0.01}\\n    ]\\n\\n    for i, params in enumerate(attempt_tolerances):\\n        if i >= max_quad_attempts: # Ensure we don't exceed the specified max attempts\\n            break\\n        \\n        try:\\n            val, err = scipy.integrate.quad(\\n                func, a, b,\\n                limit=limit_val,\\n                epsabs=params['epsabs'],\\n                epsrel=params['epsrel']\\n            )\\n            \\n            # Critical check 1: Detect NaN or Inf results for both value and error.\\n            if np.isnan(val) or np.isinf(val) or \\\\\\n               np.isnan(err) or np.isinf(err):\\n                if i == len(attempt_tolerances) - 1 or i == max_quad_attempts - 1:\\n                    raise ValueError(f\\"Scipy quad returned NaN or Inf result after {i+1} internal attempt(s).\\")\\n                continue # Try next tighter tolerance\\n            \\n            # Critical check 2: Verify if the requested precision was met.\\n            # \`quad\`'s documentation states it tries to achieve \`err <= max(epsabs, abs(val) * epsrel)\`.\\n            requested_tolerance_target = max(params['epsabs'], abs(val) * params['epsrel'])\\n            \\n            # Allow a small fudge factor (1 + 1e-6) for floating-point precision in comparison.\\n            # If the error is slightly above tolerance, it might still be acceptable for practical purposes.\\n            if err > requested_tolerance_target * (1 + 1e-6):\\n                if i == len(attempt_tolerances) - 1 or i == max_quad_attempts - 1:\\n                    raise ValueError(f\\"Scipy quad failed to meet requested precision after {i+1} internal attempt(s): returned_err={err:.2e}, requested_tol={requested_tolerance_target:.2e}.\\")\\n                continue # Try next tighter tolerance\\n            \\n            return val, err\\n        except Exception as e:\\n            # Catch any exception from quad itself or from our checks.\\n            if i == len(attempt_tolerances) - 1 or i == max_quad_attempts - 1:\\n                raise ValueError(f\\"Scipy quad call failed or its result deemed unreliable after {i+1} internal attempt(s): {e}\\")\\n            continue # Try next tighter tolerance\\n    \\n    # This line should theoretically not be reached if max_quad_attempts is handled correctly within the loop,\\n    # but as a safety fallback.\\n    raise ValueError(\\"All scipy quad internal attempts failed without returning a result.\\")\\n\\n\\ndef _integrate_semi_infinite(integrand: Callable[float, float], lower_limit: float) -> Tuple[float, float]:\\n    \\"\\"\\"\\n    Specialized method for [a, inf) integrals using segment summation and Euler acceleration.\\n    \\"\\"\\"\\n    current_segment_start = float(lower_limit)\\n    \\n    # Adaptive initial segment length strategy to better capture oscillation periods.\\n    initial_segment_candidates = [0.01, 0.1, 0.5, 1.0, math.pi / 2.0, math.pi, 2 * math.pi]\\n    found_initial_segment = False\\n    \\n    initial_seg_val, initial_seg_err = 0.0, 0.0\\n    chosen_initial_segment_length = initial_segment_candidates[0] # Default to smallest\\n\\n    for seg_len_candidate in initial_segment_candidates:\\n        seg_end_candidate = current_segment_start + seg_len_candidate\\n        if seg_end_candidate <= current_segment_start + 1e-12: # Avoid numerically tiny segments\\n            continue\\n        try:\\n            # Integrate the first segment with high precision.\\n            initial_seg_val, initial_seg_err = _robust_quad_call(\\n                integrand, current_segment_start, seg_end_candidate,\\n                limit_val=2000000, epsabs_val=1e-10, epsrel_val=1e-10, max_quad_attempts=5\\n            )\\n            found_initial_segment = True\\n            chosen_initial_segment_length = seg_len_candidate\\n            current_segment_start = seg_end_candidate\\n            break\\n        except ValueError:\\n            pass # Try next candidate segment length\\n    \\n    if not found_initial_segment:\\n        # If no initial segment integrated reliably, the integral is likely pathological.\\n        return np.nan, np.inf\\n\\n    segment_integrals = [initial_seg_val]\\n    total_quad_error_sq = initial_seg_err ** 2\\n\\n    # Segment growth factor (fixed exponential growth)\\n    segment_growth_factor = 1.2\\n    \\n    # Main loop parameters for segment computation\\n    max_segments_to_compute = 50000  # Reduced max segments to improve efficiency.\\n    min_segments_for_euler = 30     # Minimum segments required for reliable Euler acceleration.\\n    \\n    # Euler acceleration tolerances and convergence criteria\\n    euler_abs_tol = 1e-10\\n    euler_rel_tol = 1e-8\\n    target_consecutive_converged = 7 # Reduced for faster convergence detection in Euler.\\n\\n    # Minimum error threshold to avoid reporting zero error when uncertainty exists.\\n    MIN_ERROR_THRESHOLD = 1e-15 \\n\\n    prev_seg_val = initial_seg_val\\n    consistent_sign_count = 0\\n    consecutive_decay_count = 0\\n\\n    for i in range(1, max_segments_to_compute):\\n        seg_start = current_segment_start\\n        # Grow the segment length based on the successfully chosen initial_segment_length\\n        segment_len = chosen_initial_segment_length * (segment_growth_factor ** i)\\n        seg_end = seg_start + segment_len\\n\\n        if seg_end - seg_start < 1e-12: # Avoid numerically tiny segments\\n            break\\n\\n        try:\\n            # Integrate each subsequent segment.\\n            seg_val, seg_err = _robust_quad_call(\\n                integrand, seg_start, seg_end,\\n                limit_val=1000000, epsabs_val=euler_abs_tol, epsrel_val=euler_rel_tol, max_quad_attempts=3\\n            )\\n            total_quad_error_sq += seg_err ** 2\\n        except ValueError:\\n            # If a segment fails, return current sum with a conservative error based on recent terms.\\n            current_sum_so_far = np.sum(segment_integrals) if segment_integrals else 0.0\\n            error_on_segment_failure_component = np.sum(np.abs(segment_integrals[max(0, len(segment_integrals) - min(10, len(segment_integrals))):])) # Use last 10 terms for tail error\\n            final_error = math.sqrt(error_on_segment_failure_component**2 + total_quad_error_sq)\\n            return current_sum_so_far, max(final_error, MIN_ERROR_THRESHOLD)\\n\\n        segment_integrals.append(seg_val)\\n        current_segment_start = seg_end\\n\\n        # Heuristic checks for series behavior to potentially stop early\\n        \\n        # Check 1: Consistent non-alternating signs. Euler works best for alternating series.\\n        if abs(seg_val) > euler_abs_tol * 0.01: # Only check sign if term is not near zero\\n            if seg_val * prev_seg_val >= 0:\\n                consistent_sign_count += 1\\n            else:\\n                consistent_sign_count = 0\\n        else:\\n            consistent_sign_count = 0 # Reset if terms are tiny.\\n        \\n        # If series becomes non-alternating for enough terms, stop early.\\n        if consistent_sign_count >= 10 and i >= min_segments_for_euler: # Reduced threshold for consistent sign\\n            current_sum_so_far = np.sum(segment_integrals)\\n            error_on_non_alternating_component = np.sum(np.abs(segment_integrals[max(0, len(segment_integrals) - min(10, len(segment_integrals))):]))\\n            final_error = math.sqrt(error_on_non_alternating_component**2 + total_quad_error_sq)\\n            return current_sum_so_far, max(final_error, MIN_ERROR_THRESHOLD)\\n\\n        # Check 2: Rapid decay of terms. If terms quickly become very small, the series might already be converging.\\n        current_sum_overall = np.sum(segment_integrals)\\n        if abs(seg_val) < (euler_abs_tol * 0.0001) and \\\\\\n           (abs(seg_val) < (euler_rel_tol * 0.0001 * abs(current_sum_overall) if current_sum_overall != 0 else euler_abs_tol * 0.0001)):\\n            consecutive_decay_count += 1\\n            if consecutive_decay_count >= 10: # Reduced threshold for consecutive decay\\n                break\\n        else:\\n            consecutive_decay_count = 0\\n\\n        # Check 3: Strong divergence. If terms are growing rapidly, the integral likely diverges.\\n        if i >= min_segments_for_euler and \\\\\\n           abs(prev_seg_val) > euler_abs_tol * 0.01 and \\\\\\n           abs(seg_val) > abs(prev_seg_val) * 50: # Reduced factor for divergence detection\\n            current_sum_so_far = np.sum(segment_integrals)\\n            error_on_divergence_component = np.sum(np.abs(segment_integrals[max(0, len(segment_integrals) - min(10, len(segment_integrals))):]))\\n            final_error = math.sqrt(error_on_divergence_component**2 + total_quad_error_sq)\\n            return current_sum_so_far, max(final_error, MIN_ERROR_THRESHOLD)\\n\\n        prev_seg_val = seg_val\\n\\n    # Sum of segments before Euler acceleration (used as a fallback if Euler fails)\\n    initial_sum_segments = np.sum(segment_integrals) if segment_integrals else 0.0\\n    N_segments = len(segment_integrals)\\n\\n    # If not enough terms for Euler acceleration, return the direct sum.\\n    if N_segments < min_segments_for_euler:\\n        if N_segments > 0:\\n            error_estimate_no_euler_component = np.sum(np.abs(segment_integrals[max(0, N_segments - min(10, N_segments)):]))\\n            final_error = math.sqrt(error_estimate_no_euler_component**2 + total_quad_error_sq)\\n            return initial_sum_segments, max(final_error, MIN_ERROR_THRESHOLD)\\n        return initial_sum_segments, np.inf # Should not happen if first segment logic works\\n\\n    # Apply Euler's Transformation (series acceleration) to the collected segment integrals.\\n    euler_current_sequence = np.array(segment_integrals, dtype=float)\\n    euler_diagonal_values = [euler_current_sequence[0]] \\n    consecutive_converged_count = 0 \\n\\n    try:\\n        max_euler_levels = N_segments - 1\\n\\n        for m in range(max_euler_levels): \\n            if len(euler_current_sequence) < 2:\\n                break # Not enough terms for further transformation\\n            \\n            # Compute the next level of Euler transform\\n            new_euler_sequence_array = (euler_current_sequence[:-1] + euler_current_sequence[1:]) / 2.0\\n            euler_current_sequence = new_euler_sequence_array\\n            \\n            if len(euler_current_sequence) == 0:\\n                break # Sequence became empty\\n\\n            current_euler_val = euler_current_sequence[0] \\n            euler_diagonal_values.append(current_euler_val) \\n            \\n            # Check for convergence in the Euler diagonal values.\\n            if m > 0 and len(euler_diagonal_values) >= 2:\\n                prev_euler_val = euler_diagonal_values[-2]\\n                diff = abs(current_euler_val - prev_euler_val)\\n                \\n                is_relative_converged = (abs(current_euler_val) > euler_abs_tol) and \\\\\\n                                         (diff < euler_rel_tol * abs(current_euler_val))\\n                is_absolute_converged = (abs(current_euler_val) <= euler_abs_tol) and \\\\\\n                                         (diff < euler_abs_tol * 0.1) # Check if diff is small relative to abs_tol\\n                \\n                if is_relative_converged or is_absolute_converged:\\n                    consecutive_converged_count += 1\\n                else:\\n                    consecutive_converged_count = 0 \\n                \\n                if consecutive_converged_count >= target_consecutive_converged:\\n                    break # Euler transformation converged!\\n                \\n                # Check for strong divergence in the Euler diagonal itself\\n                if m > 2 and abs(prev_euler_val) > euler_abs_tol * 0.01 and \\\\\\n                   abs(current_euler_val) > abs(prev_euler_val) * 50: # Factor 50 for divergence\\n                    error_on_euler_divergence_component = np.sum(np.abs(segment_integrals[max(0, N_segments - min(10, N_segments)):]))\\n                    final_error = math.sqrt(error_on_euler_divergence_component**2 + total_quad_error_sq)\\n                    return initial_sum_segments, max(final_error, MIN_ERROR_THRESHOLD)\\n\\n    except Exception:\\n        # If any error occurs during Euler transformation, return the initial sum.\\n        error_on_euler_exception_component = np.sum(np.abs(segment_integrals[max(0, N_segments - min(10, N_segments)):]))\\n        final_error = math.sqrt(error_on_euler_exception_component**2 + total_quad_error_sq)\\n        return initial_sum_segments, max(final_error, MIN_ERROR_THRESHOLD)\\n\\n    # The final answer is the last value obtained in the Euler diagonal sequence.\\n    final_answer = euler_diagonal_values[-1] if len(euler_diagonal_values) > 0 else initial_sum_segments\\n    \\n    # Calculate the error estimate for the Euler transformed result.\\n    euler_error_component = np.inf \\n\\n    if len(euler_diagonal_values) >= 2:\\n        last_diff_euler = abs(euler_diagonal_values[-1] - euler_diagonal_values[-2])\\n        \\n        if consecutive_converged_count >= target_consecutive_converged:\\n            # If converged, error is based on last difference or requested tolerance\\n            euler_error_component = max(last_diff_euler, \\n                                 euler_rel_tol * abs(final_answer), \\n                                 euler_abs_tol, MIN_ERROR_THRESHOLD) \\n        else:\\n            # If not converged, error is higher, e.g., last difference times a safety factor.\\n            # This indicates less confidence in the acceleration.\\n            euler_error_component = max(last_diff_euler * 5, \\n                                 euler_rel_tol * abs(final_answer) * 5, \\n                                 euler_abs_tol * 5, MIN_ERROR_THRESHOLD) \\n    else: \\n        # If Euler did not produce enough diagonal values for a comparison, use original series tail.\\n        # This is a conservative estimate of the remaining sum.\\n        euler_error_component = np.sum(np.abs(segment_integrals[max(0, N_segments - min(10, N_segments)):]))\\n        euler_error_component = max(euler_error_component, \\n                               abs(initial_sum_segments) * euler_rel_tol * 10, \\n                               euler_abs_tol * 10, MIN_ERROR_THRESHOLD)\\n    \\n    final_error_estimate = math.sqrt(euler_error_component**2 + total_quad_error_sq)\\n    final_error_estimate = max(final_error_estimate, MIN_ERROR_THRESHOLD)\\n\\n    # Final checks for NaN/Inf results\\n    if np.isnan(final_answer) or np.isinf(final_answer):\\n        return np.nan, np.inf\\n    if np.isnan(final_error_estimate) or np.isinf(final_error_estimate):\\n        return final_answer, np.inf\\n\\n    return final_answer, final_error_estimate\\n\\n\\ndef quadrature(\\n    integrand: Callable[float, float],\\n    lower_limit: float,\\n    upper_limit: float,\\n) -> Tuple[float, float]:\\n    \\"\\"\\"\\n    Estimate the numeric value of the definite integral, especially\\n    when scipy.integrate.quad() fails to converge or returns a large error\\n    estimate or NaN.\\n    \\"\\"\\"\\n\\n    # Handle trivial case where limits are the same\\n    if lower_limit == upper_limit:\\n        return 0.0, 0.0\\n\\n    # --- Step 1: Tiered Attempts with scipy.integrate.quad() on the original interval ---\\n    # These attempts use increasingly stringent parameters for general convergence.\\n    quad_attempts = [\\n        {'limit': 500000, 'epsabs': 1e-10, 'epsrel': 1e-10},\\n        {'limit': 1000000, 'epsabs': 1e-12, 'epsrel': 1e-12},\\n        {'limit': 2000000, 'epsabs': 1e-13, 'epsrel': 1e-13}\\n    ]\\n\\n    for attempt_params in quad_attempts:\\n        try:\\n            answer, error_estimate = _robust_quad_call(\\n                integrand, lower_limit, upper_limit,\\n                limit_val=attempt_params['limit'],\\n                epsabs_val=attempt_params['epsabs'],\\n                epsrel_val=attempt_params['epsrel'],\\n                max_quad_attempts=3 # Allow internal retries within _robust_quad_call\\n            )\\n            return answer, error_estimate\\n        except ValueError:\\n            pass # If _robust_quad_call raises ValueError, this attempt failed, try next.\\n\\n    # --- Step 2: Handle Infinite Limits via Transformations or Splitting ---\\n    # If all direct quad attempts failed, we now apply transformations for infinite domains.\\n    \\n    # Case: (-inf, inf)\\n    if lower_limit == -np.inf and upper_limit == np.inf:\\n        try:\\n            # First, try quad directly on (-inf, inf) with high limits\\n            ans_direct_inf, err_direct_inf = _robust_quad_call(\\n                integrand, -np.inf, np.inf,\\n                limit_val=2000000, epsabs_val=1e-12, epsrel_val=1e-12, max_quad_attempts=3\\n            )\\n            return ans_direct_inf, err_direct_inf\\n        except ValueError:\\n            # Fallback to splitting into three parts for better robustness if direct call fails.\\n            # Using -1.0 and 1.0 as split points to avoid issues at 0.0\\n            try:\\n                val1, err1 = quadrature(integrand, -np.inf, -1.0)\\n                val2, err2 = quadrature(integrand, -1.0, 1.0) # Finite interval\\n                val3, err3 = quadrature(integrand, 1.0, np.inf)\\n\\n                # Check for problematic results from sub-integrals\\n                if np.isnan(val1) or np.isinf(val1) or \\\\\\n                   np.isnan(val2) or np.isinf(val2) or \\\\\\n                   np.isnan(val3) or np.isinf(val3):\\n                    return np.nan, np.inf\\n                \\n                # Combine errors in quadrature: sqrt(sum of squares of errors)\\n                total_err_combined = math.sqrt(err1**2 + err2**2 + err3**2)\\n                \\n                return val1 + val2 + val3, total_err_combined\\n            except Exception: # Catch any exceptions during the splitting or summation.\\n                return np.nan, np.inf\\n\\n    # Case: (-inf, b] where b is finite\\n    elif lower_limit == -np.inf and upper_limit != np.inf: \\n        # Transformation: let x = -t. Then dx = -dt.\\n        # Original limits: x -> -inf (t -> inf); x -> upper_limit (t -> -upper_limit).\\n        # The integral becomes: Integral from inf to -upper_limit of f(-t) (-dt)\\n        # which simplifies to: Integral from -upper_limit to inf of f(-t) dt.\\n        def transformed_integrand_neg_inf(t):\\n            return integrand(-t) \\n\\n        # Recursively call the specialized semi-infinite integrator for the transformed function and limits.\\n        return _integrate_semi_infinite(transformed_integrand_neg_inf, -upper_limit)\\n    \\n    # Case: [a, b] where a and b are finite, and all tiered quad attempts failed.\\n    # If \`scipy.integrate.quad\` (even with aggressive parameters) failed to converge on a finite interval,\\n    # it strongly suggests a pathological function or a severe singularity.\\n    # In such scenarios, returning NaN with an infinite error is the most appropriate indication of failure.\\n    elif upper_limit != np.inf: \\n        return np.nan, np.inf\\n\\n    # --- Step 3: If all previous attempts failed, call specialized method for [a, inf) ---\\n    # This part is reached only if previous \`scipy.integrate.quad\` attempts (including for transformed integrals) failed.\\n    # It applies specifically to integrals of the form [lower_limit, inf).\\n    return _integrate_semi_infinite(integrand, lower_limit)"
}`);
        const originalCode = codes["old_code"];
        const modifiedCode = codes["new_code"];
        const originalIndex = codes["old_index"];
        const modifiedIndex = codes["new_index"];

        function displaySideBySideDiff(originalText, modifiedText) {
          const diff = Diff.diffLines(originalText, modifiedText);

          let originalHtmlLines = [];
          let modifiedHtmlLines = [];

          const escapeHtml = (text) =>
            text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");

          diff.forEach((part) => {
            // Split the part's value into individual lines.
            // If the string ends with a newline, split will add an empty string at the end.
            // We need to filter this out unless it's an actual empty line in the code.
            const lines = part.value.split("\n");
            const actualContentLines =
              lines.length > 0 && lines[lines.length - 1] === "" ? lines.slice(0, -1) : lines;

            actualContentLines.forEach((lineContent) => {
              const escapedLineContent = escapeHtml(lineContent);

              if (part.removed) {
                // Line removed from original, display in original column, add blank in modified.
                originalHtmlLines.push(
                  `<span class="diff-line diff-removed">${escapedLineContent}</span>`,
                );
                // Use &nbsp; for consistent line height.
                modifiedHtmlLines.push(`<span class="diff-line">&nbsp;</span>`);
              } else if (part.added) {
                // Line added to modified, add blank in original column, display in modified.
                // Use &nbsp; for consistent line height.
                originalHtmlLines.push(`<span class="diff-line">&nbsp;</span>`);
                modifiedHtmlLines.push(
                  `<span class="diff-line diff-added">${escapedLineContent}</span>`,
                );
              } else {
                // Equal part - no special styling (no background)
                // Common line, display in both columns without any specific diff class.
                originalHtmlLines.push(`<span class="diff-line">${escapedLineContent}</span>`);
                modifiedHtmlLines.push(`<span class="diff-line">${escapedLineContent}</span>`);
              }
            });
          });

          // Join the lines and set innerHTML.
          originalDiffOutput.innerHTML = originalHtmlLines.join("");
          modifiedDiffOutput.innerHTML = modifiedHtmlLines.join("");
        }

        // Initial display with default content on DOMContentLoaded.
        displaySideBySideDiff(originalCode, modifiedCode);

        // Title the texts with their node numbers.
        originalTitle.textContent = `Parent #${originalIndex}`;
        modifiedTitle.textContent = `Child #${modifiedIndex}`;
      }

      // Load the jsdiff script when the DOM is fully loaded.
      document.addEventListener("DOMContentLoaded", loadJsDiff);
    </script>
  </body>
</html>
