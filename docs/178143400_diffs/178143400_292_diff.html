<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Diff Viewer</title>
    <!-- Google "Inter" font family -->
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Inter", sans-serif;
        display: flex;
        margin: 0; /* Simplify bounds so the parent can determine the correct iFrame height. */
        padding: 0;
        overflow: hidden; /* Code can be long and wide, causing scroll-within-scroll. */
      }

      .container {
        padding: 1.5rem;
        background-color: #fff;
      }

      h2 {
        font-size: 1.5rem;
        font-weight: 700;
        color: #1f2937;
        margin-bottom: 1rem;
        text-align: center;
      }

      .diff-output-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1rem;
        background-color: #f8fafc;
        border: 1px solid #e2e8f0;
        border-radius: 0.75rem;
        box-shadow:
          0 4px 6px -1px rgba(0, 0, 0, 0.1),
          0 2px 4px -1px rgba(0, 0, 0, 0.06);
        padding: 1.5rem;
        font-size: 0.875rem;
        line-height: 1.5;
      }

      .diff-original-column {
        padding: 0.5rem;
        border-right: 1px solid #cbd5e1;
        min-height: 150px;
      }

      .diff-modified-column {
        padding: 0.5rem;
        min-height: 150px;
      }

      .diff-line {
        display: block;
        min-height: 1.5em;
        padding: 0 0.25rem;
        white-space: pre-wrap;
        word-break: break-word;
      }

      .diff-added {
        background-color: #d1fae5;
        color: #065f46;
      }
      .diff-removed {
        background-color: #fee2e2;
        color: #991b1b;
        text-decoration: line-through;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="diff-output-container">
        <div class="diff-original-column">
          <h2 id="original-title">Before</h2>
          <pre id="originalDiffOutput"></pre>
        </div>
        <div class="diff-modified-column">
          <h2 id="modified-title">After</h2>
          <pre id="modifiedDiffOutput"></pre>
        </div>
      </div>
    </div>
    <script>
      // Function to dynamically load the jsdiff library.
      function loadJsDiff() {
        const script = document.createElement("script");
        script.src = "https://cdnjs.cloudflare.com/ajax/libs/jsdiff/8.0.2/diff.min.js";
        script.integrity =
          "sha512-8pp155siHVmN5FYcqWNSFYn8Efr61/7mfg/F15auw8MCL3kvINbNT7gT8LldYPq3i/GkSADZd4IcUXPBoPP8gA==";
        script.crossOrigin = "anonymous";
        script.referrerPolicy = "no-referrer";
        script.onload = populateDiffs; // Call populateDiffs after the script is loaded
        script.onerror = () => {
          console.error("Error: Failed to load jsdiff library.");
          const originalDiffOutput = document.getElementById("originalDiffOutput");
          if (originalDiffOutput) {
            originalDiffOutput.innerHTML =
              '<p style="color: #dc2626; text-align: center; padding: 2rem;">Error: Diff library failed to load. Please try refreshing the page or check your internet connection.</p>';
          }
          const modifiedDiffOutput = document.getElementById("modifiedDiffOutput");
          if (modifiedDiffOutput) {
            modifiedDiffOutput.innerHTML = "";
          }
        };
        document.head.appendChild(script);
      }

      function populateDiffs() {
        const originalDiffOutput = document.getElementById("originalDiffOutput");
        const modifiedDiffOutput = document.getElementById("modifiedDiffOutput");
        const originalTitle = document.getElementById("original-title");
        const modifiedTitle = document.getElementById("modified-title");

        // Check if jsdiff library is loaded.
        if (typeof Diff === "undefined") {
          console.error("Error: jsdiff library (Diff) is not loaded or defined.");
          // This case should ideally be caught by script.onerror, but keeping as a fallback.
          if (originalDiffOutput) {
            originalDiffOutput.innerHTML =
              '<p style="color: #dc2626; text-align: center; padding: 2rem;">Error: Diff library failed to load. Please try refreshing the page or check your internet connection.</p>';
          }
          if (modifiedDiffOutput) {
            modifiedDiffOutput.innerHTML = ""; // Clear modified output if error
          }
          return; // Exit since jsdiff is not loaded.
        }

        // The injected codes to display.
        const codes = JSON.parse(`{
  "old_index": 274.0,
  "old_code": "# TODO: Implement the \`quadrature()\` function to numerically evaluate integrals.\\n\\nimport math\\nfrom typing import Any, Callable, Tuple\\nimport numpy as np\\nimport scipy.integrate\\nimport scipy.optimize\\n\\ndef quadrature(\\n    integrand: Callable[float, float],\\n    lower_limit: float,\\n    upper_limit: float,\\n) -> Tuple[float, float]:\\n    \\"\\"\\"\\n    Estimate the numeric value of the definite integral, especially\\n    when scipy.integrate.quad() fails to converge or returns a large error\\n    estimate or NaN.\\n    \\"\\"\\"\\n\\n    # --- Step 1: Initial Attempt with scipy.integrate.quad() ---\\n    try:\\n        # Pushing scipy.integrate.quad harder with higher limits and tighter absolute/relative tolerance\\n        # Using more realistic tight tolerances for float64 machine epsilon (~2.22e-16).\\n        # Increased limit significantly.\\n        \\n        # Identify potential difficult points for quad. For oscillatory integrals, 0 is often one.\\n        # This is a heuristic and might not always apply.\\n        quad_points = []\\n        # Add 0 as a point if it's within the interval or a boundary for infinite integrals\\n        if (lower_limit < 0 < upper_limit) or \\\\\\n           (lower_limit == -np.inf and upper_limit == np.inf) or \\\\\\n           (lower_limit == 0 and upper_limit == np.inf) or \\\\\\n           (lower_limit == -np.inf and upper_limit == 0):\\n            quad_points.append(0.0)\\n        \\n        answer, error_estimate = scipy.integrate.quad(\\n            integrand, lower_limit, upper_limit,\\n            limit=100000,     # Max subintervals, greatly increased\\n            epsabs=1e-15,   # Absolute error tolerance, tightened towards machine epsilon\\n            epsrel=1e-15,    # Relative error tolerance, tightened towards machine epsilon\\n            points=quad_points if quad_points else None\\n        )\\n\\n        # Check for NaN or Inf results/errors from quad, or if error is too high\\n        # A result is considered unreliable if:\\n        # 1. Result or error estimate is NaN/Inf.\\n        # 2. For larger answers (abs > 1e-8), relative error is > 1e-4 (0.01%).\\n        # 3. For tiny answers (abs <= 1e-8), absolute error is > 1e-10.\\n        if (np.isnan(answer) or np.isinf(answer) or\\n            np.isnan(error_estimate) or np.isinf(error_estimate) or\\n            (abs(answer) > 1e-8 and error_estimate / abs(answer) > 1e-4) or\\n            (abs(answer) <= 1e-8 and error_estimate > 1e-10)):\\n            raise ValueError(\\"scipy.integrate.quad failed to converge reliably or error is too high in initial attempt.\\")\\n            \\n        return answer, error_estimate\\n    except Exception:\\n        pass # Continue to specialized method\\n\\n    # --- Step 2: Handle Infinite Limits via Transformation to Finite Interval ---\\n    # This approach transforms infinite integrals to finite ones, often\\n    # helping scipy.integrate.quad to handle oscillating integrands or\\n    # those with slow decay more effectively, especially by hinting potential\\n    # singularities at the new limits.\\n\\n    try:\\n        # Parameters for transformed integrals - extremely aggressive\\n        trans_limit = 150000 # Even higher limit for transformed integral\\n        trans_eps = 1e-15    # Same tight epsilons\\n\\n        if lower_limit == -np.inf and upper_limit == np.inf: # Case: (-inf, inf)\\n            # Transformation: x = tan(t), dx = sec^2(t) dt\\n            # Limits: x -> -inf implies t -> -pi/2; x -> inf implies t -> pi/2\\n            # Integral becomes int_{-pi/2}^{pi/2} f(tan(t)) * sec^2(t) dt\\n            # This is more direct than splitting at 0 and recursively calling \`quadrature\`.\\n            def transformed_integrand_neg_inf_pos_inf(t):\\n                sec_t = 1.0 / math.cos(t)\\n                return integrand(math.tan(t)) * (sec_t ** 2)\\n            \\n            # Hint singularities at pi/2 and -pi/2\\n            answer, error_estimate = scipy.integrate.quad(\\n                transformed_integrand_neg_inf_pos_inf, -math.pi / 2, math.pi / 2,\\n                limit=trans_limit, epsabs=trans_eps, epsrel=trans_eps,\\n                points=[-math.pi / 2, 0.0, math.pi / 2] # Specify singularities at limits and 0\\n            )\\n\\n        elif lower_limit == -np.inf and upper_limit != np.inf: # Case: (-inf, b]\\n            # Transformation: x = upper_limit - tan(t), dx = -sec^2(t) dt\\n            # Limits: x -> -inf implies t -> pi/2; x -> upper_limit implies t -> 0\\n            # Integral becomes int_{pi/2}^{0} f(upper_limit - tan(t)) * (-sec^2(t)) dt\\n            # Which is int_{0}^{pi/2} f(upper_limit - tan(t)) * sec^2(t) dt\\n            def transformed_integrand_neg_inf_b(t):\\n                sec_t = 1.0 / math.cos(t)\\n                return integrand(upper_limit - math.tan(t)) * (sec_t ** 2)\\n            \\n            # Hint singularity at pi/2 (where tan(t) and sec^2(t) diverge)\\n            answer, error_estimate = scipy.integrate.quad(\\n                transformed_integrand_neg_inf_b, 0, math.pi / 2,\\n                limit=trans_limit, epsabs=trans_eps, epsrel=trans_eps,\\n                points=[math.pi / 2] # Specify singularity at upper limit\\n            )\\n            \\n        elif upper_limit == np.inf: # Case: [a, inf)\\n            # Transformation: x = lower_limit + tan(t), dx = sec^2(t) dt\\n            # Limits: x -> lower_limit implies t -> 0; x -> inf implies t -> pi/2\\n            # Integral becomes int_{0}^{pi/2} f(lower_limit + tan(t)) * sec^2(t) dt\\n            def transformed_integrand_pos_inf_a(t):\\n                sec_t = 1.0 / math.cos(t)\\n                return integrand(lower_limit + math.tan(t)) * (sec_t ** 2)\\n            \\n            # Hint singularity at pi/2\\n            answer, error_estimate = scipy.integrate.quad(\\n                transformed_integrand_pos_inf_a, 0, math.pi / 2,\\n                limit=trans_limit, epsabs=trans_eps, epsrel=trans_eps,\\n                points=[math.pi / 2] # Specify singularity at upper limit\\n            )\\n\\n        else: # Finite interval [a,b] where original quad failed - retry with very aggressive settings\\n            answer, error_estimate = scipy.integrate.quad(\\n                integrand, lower_limit, upper_limit,\\n                limit=trans_limit, epsabs=trans_eps, epsrel=trans_eps\\n            )\\n        \\n        # Check for NaN/Inf/high error from transformed integral.\\n        # Even tighter error criteria for this robust step.\\n        if (np.isnan(answer) or np.isinf(answer) or\\n            np.isnan(error_estimate) or np.isinf(error_estimate) or\\n            (abs(answer) > 1e-10 and error_estimate / abs(answer) > 1e-5) or # Tighter relative error (0.001%)\\n            (abs(answer) <= 1e-10 and error_estimate > 1e-14)): # Tighter absolute error\\n            raise ValueError(\\"Transformed integral also failed to converge reliably.\\")\\n        \\n        return answer, error_estimate\\n    except Exception:\\n        # If transformation or its quad call fails, fall back to Euler acceleration\\n        pass\\n\\n    # --- Step 3: Specialized Fallback for Oscillatory Integrals (Euler Acceleration) ---\\n    # This method is for [a, inf) or finite [a, b] where previous methods failed.\\n    # It uses fixed-length segment summation and Euler acceleration.\\n    # It's intended as a last resort, especially for cases like sin(x)/x.\\n\\n    # Adjust integrand and limits for Euler if needed, ensuring it's always [A, inf) for Euler's series summation.\\n    euler_integrand = integrand\\n    euler_lower_limit = lower_limit\\n    euler_upper_limit = upper_limit\\n\\n    if euler_lower_limit == -np.inf: # If we are still dealing with -inf, transform it\\n        if euler_upper_limit == np.inf: # (-inf, inf) at this stage. All previous methods failed.\\n            # This is extremely difficult to handle generically with Euler.\\n            # Return NaN, Inf as a failure.\\n            return np.nan, np.inf\\n        else: # Case: (-inf, b]\\n            # Transformation: y = upper_limit - x, dx = -dy\\n            # Limits: x -> -inf implies y -> inf; x -> upper_limit implies y -> 0\\n            # Integral becomes int_{inf}^{0} f(upper_limit - y) (-dy)\\n            # Which is int_{0}^{inf} f(upper_limit - y) dy\\n            def transformed_integrand_for_euler_neg_inf(y):\\n                return integrand(euler_upper_limit - y)\\n            \\n            euler_integrand = transformed_integrand_for_euler_neg_inf\\n            euler_lower_limit = 0.0 # New lower limit\\n            euler_upper_limit = np.inf # New upper limit\\n\\n    # At this point, euler_lower_limit is finite and euler_upper_limit is either finite or inf.\\n\\n    current_segment_start = float(euler_lower_limit)\\n    segment_length = math.pi  # Heuristic for half-period of common oscillations (sin(x), cos(x))\\n    \\n    segment_integrals = []\\n    \\n    max_segments_to_compute = 10000 # Increased max segments for potentially slower convergence\\n    min_segments_for_euler = 50     # Increased min terms for Euler transformation to be meaningful.\\n\\n    prev_seg_val = None\\n    consistent_sign_count = 0 \\n    consecutive_decay_count = 0 \\n\\n    # If the finite interval is too small for segmentation, just try quad very aggressively one last time.\\n    if euler_upper_limit != np.inf and (euler_upper_limit - euler_lower_limit) < segment_length:\\n        try:\\n            answer, error_estimate = scipy.integrate.quad(\\n                euler_integrand, euler_lower_limit, euler_upper_limit,\\n                limit=200000, epsabs=1e-15, epsrel=1e-15\\n            )\\n            # If still problematic, raise error to be caught below or propagate NaN\\n            if (np.isnan(answer) or np.isinf(answer) or error_estimate > 1e-10):\\n                 raise ValueError(\\"Small finite interval quad failed even in Euler fallback.\\")\\n            return answer, error_estimate\\n        except Exception:\\n            return np.nan, np.inf # Indicate ultimate failure\\n\\n    for i in range(max_segments_to_compute):\\n        seg_start = current_segment_start\\n        seg_end = current_segment_start + segment_length\\n\\n        # Clamp seg_end to upper_limit if it's finite and exceeded\\n        if euler_upper_limit != np.inf and seg_end > euler_upper_limit:\\n            seg_end = euler_upper_limit\\n        \\n        # If this segment is too short or we've passed the upper limit\\n        if seg_end <= seg_start + 1e-12: # Add a small epsilon to ensure non-zero length\\n            break \\n\\n        try:\\n            # Use aggressive quad parameters for segment integration\\n            seg_val, seg_err = scipy.integrate.quad(\\n                euler_integrand, seg_start, seg_end,\\n                limit=10000, epsabs=1e-20, epsrel=1e-20 # Tighter epsilons and higher limit for segments\\n            )\\n            \\n            # If segment integral fails to converge to a very small error, this whole method might be unsuitable\\n            if np.isnan(seg_val) or np.isinf(seg_val) or seg_err > 1e-10: \\n                raise ValueError(f\\"Segment integration failed at {i}-th segment with val={seg_val}, err={seg_err}\\")\\n\\n            segment_integrals.append(seg_val)\\n            current_segment_start = seg_end # Move to the end of the current segment\\n\\n            # Early exit if we reached the finite upper_limit\\n            if euler_upper_limit != np.inf and current_segment_start >= euler_upper_limit - 1e-9: # Account for float precision near limit\\n                break\\n\\n            # --- Checks for suitability of Euler transformation and early convergence ---\\n            if i > 0:\\n                # Check for alternating signs (crucial for Euler)\\n                if seg_val * prev_seg_val >= 0 and abs(seg_val) > 1e-18: # Lower magnitude threshold for sign check\\n                    consistent_sign_count += 1\\n                else:\\n                    consistent_sign_count = 0 # Reset if signs alternate\\n                \\n                # If signs consistently do not alternate after a few initial terms, Euler transformation is not suitable.\\n                # This often indicates divergence or non-oscillatory behavior not suited for Euler.\\n                if consistent_sign_count >= 20 and i >= min_segments_for_euler: \\n                    return np.sum(segment_integrals), np.inf # High error, as Euler won't help much (potential divergence)\\n\\n                # Check for rapid decay: if terms are consistently very small, implies convergence\\n                if abs(seg_val) < 1e-18: \\n                    consecutive_decay_count += 1\\n                    if consecutive_decay_count >= 15: # 15 consecutive very small terms means negligible contribution\\n                        if abs(np.sum(segment_integrals[:-15])) < 1e-10: # Ensure the sum before this decay is also small.\\n                            break \\n                else:\\n                    consecutive_decay_count = 0\\n                    \\n                # Check for strong divergence: if terms start to grow significantly after an initial phase\\n                if i >= min_segments_for_euler and abs(seg_val) > abs(segment_integrals[-2]) * 1000 and abs(segment_integrals[-2]) > 1e-15: \\n                    # If Euler sum starts diverging, revert to the last stable estimate.\\n                    # For a competition, we might return the sum so far with inf error.\\n                    return np.sum(segment_integrals), np.inf # Indicate divergence\\n\\n            prev_seg_val = seg_val\\n\\n        except Exception as e:\\n            # If any segment integration fails, return the sum of successful segments\\n            # with a high error to indicate uncertainty.\\n            return np.sum(segment_integrals), np.inf\\n\\n    # --- Step 4: Apply Series Acceleration (Euler's Transformation) ---\\n    N = len(segment_integrals)\\n    if N < min_segments_for_euler:\\n        # Not enough terms collected for Euler transformation, return simple sum\\n        return np.sum(segment_integrals), np.inf # High uncertainty\\n\\n    euler_sums = np.array(segment_integrals, dtype=float)\\n    \\n    # Initialize with the direct sum as a first rough estimate for comparison\\n    euler_diagonal_values = [np.sum(segment_integrals)] \\n    original_sum = np.sum(segment_integrals)\\n\\n    try:\\n        max_euler_levels = N - 1\\n        \\n        for m in range(max_euler_levels): \\n            if len(euler_sums) < 2: \\n                break # Not enough terms to continue transformation\\n            \\n            # Standard Euler transformation step\\n            new_euler_sums = (euler_sums[:-1] + euler_sums[1:]) / 2.0\\n            euler_sums = new_euler_sums\\n            \\n            current_euler_estimate = euler_sums[0]\\n            euler_diagonal_values.append(current_euler_estimate) \\n            \\n            # Check for convergence of the Euler sum by comparing the last two diagonal elements\\n            if m > 0:\\n                diff = abs(euler_diagonal_values[-1] - euler_diagonal_values[-2])\\n                # Converged if difference is very small relatively OR absolutely\\n                if (abs(euler_diagonal_values[-1]) > 1e-15 and diff < 1e-14 * abs(euler_diagonal_values[-1])) or \\\\\\n                   (abs(euler_diagonal_values[-1]) <= 1e-15 and diff < 1e-20): \\n                    break\\n                \\n                # Check for strong divergence in Euler diagonal\\n                if m > 2 and abs(euler_diagonal_values[-1]) > abs(euler_diagonal_values[-2]) * 2 and abs(euler_diagonal_values[-2]) > 1e-15: \\n                    # If Euler sum starts diverging, revert to the last stable estimate.\\n                    # For a competition, we might return the sum so far with inf error.\\n                    final_answer = euler_diagonal_values[-2] if len(euler_diagonal_values) >= 2 else original_sum\\n                    error_estimate = np.inf # Indicate divergence\\n                    return final_answer, error_estimate\\n\\n    except Exception:\\n        # If any error during Euler transformation, return the simple sum with high error.\\n        pass\\n\\n    # Final Answer Selection and Error Estimation for Euler\\n    # Take the last Euler estimate if available, otherwise the direct sum.\\n    final_answer = euler_diagonal_values[-1] if len(euler_diagonal_values) > 0 else original_sum\\n    \\n    if len(euler_diagonal_values) >= 2:\\n        # The error is approximately the difference between the last two computed Euler sums.\\n        error_estimate = abs(euler_diagonal_values[-1] - euler_diagonal_values[-2])\\n        # Add a small floor to the error estimate, considering machine precision\\n        error_estimate = max(error_estimate, 1e-14 * abs(final_answer), 1e-20)\\n    elif N > 0:\\n        # If Euler didn't run or produce enough terms for its own error estimate, \\n        # use a conservative estimate based on the magnitude of the last few segment integrals.\\n        error_estimate = abs(segment_integrals[-1]) * 100 \\n    else:\\n        error_estimate = np.inf # No terms were collected at all\\n\\n    # Final sanity check for NaN or Inf in the answer\\n    if np.isnan(final_answer) or np.isinf(final_answer):\\n        return np.nan, np.inf\\n\\n    return final_answer, error_estimate",
  "new_index": 292,
  "new_code": "import math\\nfrom typing import Any, Callable, Tuple\\nimport numpy as np\\nimport scipy.integrate\\nimport scipy.optimize\\n\\ndef _euler_accelerate_series(series_terms: list[float]) -> Tuple[float, float]:\\n    \\"\\"\\"\\n    Apply Euler's transformation (repeated averaging) to accelerate the convergence\\n    of an oscillating series.\\n    This method is most effective for alternating series whose terms monotonically\\n    decrease to zero, but can provide some acceleration for other oscillating series.\\n    \\"\\"\\"\\n    if not series_terms:\\n        return np.nan, np.inf\\n\\n    N = len(series_terms)\\n    # A minimum number of terms is required for meaningful acceleration\\n    min_terms_for_acceleration = 2 \\n    if N < min_terms_for_acceleration:\\n        return series_terms[0], np.inf # Not enough terms for acceleration\\n\\n    # Initialize Euler's diagonal sum with the direct sum of all terms\\n    euler_diagonal_values = [np.sum(series_terms)] \\n    \\n    # Use a copy to avoid modifying the original list in place\\n    current_level_terms = np.array(list(series_terms), dtype=float)\\n\\n    # Perform repeated averaging (Euler transformation steps)\\n    # The new estimate is the first term of the next level's averaged series\\n    for m in range(N - 1): # Max N-1 levels of transformation\\n        if len(current_level_terms) < 2:\\n            break\\n\\n        # Standard repeated averaging step: E_m^(k) = (E_m^(k-1) + E_{m+1}^(k-1)) / 2\\n        next_level_terms = (current_level_terms[:-1] + current_level_terms[1:]) / 2.0\\n        current_level_terms = next_level_terms\\n\\n        current_euler_estimate = current_level_terms[0]\\n        euler_diagonal_values.append(current_euler_estimate)\\n\\n        # Convergence check: Compare the last two Euler estimates\\n        if m > 0:\\n            diff = abs(euler_diagonal_values[-1] - euler_diagonal_values[-2])\\n            \\n            # Check for absolute convergence (for results near zero)\\n            # Check for relative convergence (for larger results)\\n            # Using very tight but reasonable machine-epsilon-aware thresholds\\n            if (abs(euler_diagonal_values[-1]) < 1e-15 and diff < 1e-20) or \\\\\\n               (abs(euler_diagonal_values[-1]) >= 1e-15 and diff / abs(euler_diagonal_values[-1]) < 1e-10):\\n                break # Converged\\n\\n            # Divergence check: If terms start growing significantly\\n            # This heuristic prevents runaway estimates for series that aren't well-behaved\\n            if m > 2 and abs(euler_diagonal_values[-1]) > abs(euler_diagonal_values[-2]) * 10 and abs(euler_diagonal_values[-2]) > 1e-15:\\n                # It's diverging. Return the last stable estimate before divergence.\\n                final_ans = euler_diagonal_values[-2] if len(euler_diagonal_values) >= 2 else euler_diagonal_values[0]\\n                return final_ans, np.inf # High error to indicate divergence\\n\\n    # Select the final answer and estimate error\\n    final_answer = euler_diagonal_values[-1]\\n    \\n    if len(euler_diagonal_values) >= 2:\\n        # Error is typically estimated as the difference between the last two successive estimates\\n        error_estimate = abs(euler_diagonal_values[-1] - euler_diagonal_values[-2])\\n        # Add a floor to the error estimate to reflect fundamental numerical precision limits\\n        error_estimate = max(error_estimate, 1e-15 * abs(final_answer), 1e-25) \\n    else:\\n        # If not enough levels were computed for a reliable Euler error estimate,\\n        # return the sum of the terms with high uncertainty.\\n        error_estimate = np.inf \\n\\n    # Final sanity check for NaN or Inf results\\n    if np.isnan(final_answer) or np.isinf(final_answer):\\n        return np.nan, np.inf\\n\\n    return final_answer, error_estimate\\n\\ndef quadrature(\\n    integrand: Callable[float, float],\\n    lower_limit: float,\\n    upper_limit: float,\\n) -> Tuple[float, float]:\\n    \\"\\"\\"\\n    Estimate the numeric value of the definite integral, especially\\n    when scipy.integrate.quad() fails to converge or returns a large error\\n    estimate or NaN.\\n    \\"\\"\\"\\n\\n    # --- Step 1: Initial Attempt with scipy.integrate.quad() ---\\n    try:\\n        # Set aggressive limits and tight tolerances for initial quad call\\n        initial_quad_limit = 100000\\n        initial_quad_eps = 1e-15 # Tight absolute/relative tolerance\\n\\n        # Identify potential difficult points for quad. For oscillatory integrals, 0 is often one.\\n        quad_points = []\\n        if (lower_limit < 0 < upper_limit) or \\\\\\n           (lower_limit == -np.inf and upper_limit == np.inf) or \\\\\\n           (lower_limit == 0 and upper_limit == np.inf) or \\\\\\n           (lower_limit == -np.inf and upper_limit == 0):\\n            quad_points.append(0.0)\\n        \\n        answer, error_estimate = scipy.integrate.quad(\\n            integrand, lower_limit, upper_limit,\\n            limit=initial_quad_limit,\\n            epsabs=initial_quad_eps,\\n            epsrel=initial_quad_eps,\\n            points=quad_points if quad_points else None\\n        )\\n\\n        # Check for NaN/Inf results/errors, or if error is considered too high\\n        if (np.isnan(answer) or np.isinf(answer) or\\n            np.isnan(error_estimate) or np.isinf(error_estimate) or\\n            (abs(answer) > 1e-8 and error_estimate / abs(answer) > 1e-4) or # Relative error > 0.01% for larger answers\\n            (abs(answer) <= 1e-8 and error_estimate > 1e-10)): # Absolute error > 1e-10 for tiny answers\\n            raise ValueError(\\"scipy.integrate.quad failed to converge reliably in initial attempt.\\")\\n            \\n        return answer, error_estimate\\n    except Exception:\\n        pass # Continue to specialized methods if initial quad fails\\n\\n    # --- Step 2: Handle (-inf, inf) by splitting ---\\n    # This is a crucial step for integrals over the entire real line if direct quad failed.\\n    # It allows each half-infinite integral to be treated independently by the subsequent strategies.\\n    if lower_limit == -np.inf and upper_limit == np.inf:\\n        try:\\n            # Recursively call quadrature for the two half-infinite intervals\\n            ans_neg_inf_0, err_neg_inf_0 = quadrature(integrand, -np.inf, 0.0)\\n            ans_0_pos_inf, err_0_pos_inf = quadrature(integrand, 0.0, np.inf)\\n            \\n            # Combine the results and errors (standard error propagation for sums)\\n            return ans_neg_inf_0 + ans_0_pos_inf, np.sqrt(err_neg_inf_0**2 + err_0_pos_inf**2)\\n        except Exception:\\n            pass # If splitting or recursive calls fail, proceed to next fallback\\n\\n    # --- Step 3: Handle Infinite Limits via Transformation to Finite Interval ---\\n    # This approach transforms infinite integrals to finite ones, often\\n    # helping scipy.integrate.quad() to handle oscillating integrands more effectively,\\n    # by concentrating difficult behavior at the new limits.\\n\\n    try:\\n        # Parameters for transformed integrals - even more aggressive\\n        trans_limit = 150000\\n        trans_eps = 1e-15 \\n\\n        # At this point, (-inf, inf) is either solved or being handled by recursive splitting.\\n        # So we only need to consider [a, inf), (-inf, b], or finite [a, b].\\n        \\n        if lower_limit == -np.inf and upper_limit != np.inf: # Case: (-inf, b]\\n            # Transformation: x = upper_limit - tan(t), dx = -sec^2(t) dt\\n            # Integral becomes int_{pi/2}^{0} f(upper_limit - tan(t)) * (-sec^2(t)) dt\\n            # Which is int_{0}^{pi/2} f(upper_limit - tan(t)) * sec^2(t) dt\\n            def transformed_integrand_neg_inf_b(t):\\n                if abs(t - math.pi / 2) < 1e-10: # Handle potential division by zero or large values near pole\\n                    return 0.0 # Contribution from f * sec^2(t) will approach zero if f(x) decays fast enough\\n                sec_t = 1.0 / math.cos(t)\\n                return integrand(upper_limit - math.tan(t)) * (sec_t ** 2)\\n            \\n            # Hint singularity at pi/2 (where tan(t) and sec^2(t) diverge)\\n            answer, error_estimate = scipy.integrate.quad(\\n                transformed_integrand_neg_inf_b, 0, math.pi / 2,\\n                limit=trans_limit, epsabs=trans_eps, epsrel=trans_eps,\\n                points=[math.pi / 2]\\n            )\\n            \\n        elif upper_limit == np.inf: # Case: [a, inf)\\n            # Transformation: x = lower_limit + tan(t), dx = sec^2(t) dt\\n            # Integral becomes int_{0}^{pi/2} f(lower_limit + tan(t)) * sec^2(t) dt\\n            def transformed_integrand_pos_inf_a(t):\\n                if abs(t - math.pi / 2) < 1e-10: # Handle potential division by zero or large values near pole\\n                    return 0.0 # Contribution from f * sec^2(t) will approach zero if f(x) decays fast enough\\n                sec_t = 1.0 / math.cos(t)\\n                return integrand(lower_limit + math.tan(t)) * (sec_t ** 2)\\n            \\n            # Hint singularity at pi/2\\n            answer, error_estimate = scipy.integrate.quad(\\n                transformed_integrand_pos_inf_a, 0, math.pi / 2,\\n                limit=trans_limit, epsabs=trans_eps, epsrel=trans_eps,\\n                points=[math.pi / 2]\\n            )\\n\\n        else: # Finite interval [a,b] where original quad failed - retry with very aggressive settings\\n            answer, error_estimate = scipy.integrate.quad(\\n                integrand, lower_limit, upper_limit,\\n                limit=trans_limit, epsabs=trans_eps, epsrel=trans_eps\\n            )\\n        \\n        # Check for NaN/Inf/high error from transformed integral. Even tighter error criteria.\\n        if (np.isnan(answer) or np.isinf(answer) or\\n            np.isnan(error_estimate) or np.isinf(error_estimate) or\\n            (abs(answer) > 1e-10 and error_estimate / abs(answer) > 1e-5) or # Tighter relative error (0.001%)\\n            (abs(answer) <= 1e-10 and error_estimate > 1e-14)): # Tighter absolute error\\n            raise ValueError(\\"Transformed integral also failed to converge reliably.\\")\\n        \\n        return answer, error_estimate\\n    except Exception:\\n        pass # If transformation or its quad call fails, fall back to Euler acceleration\\n\\n    # --- Step 4: Fallback to Euler Acceleration for [A, inf) or finite [A, B] cases ---\\n    # This method uses fixed-length segment summation and Euler acceleration.\\n    # It's intended as a last resort, especially for cases where standard quad methods\\n    # struggle with oscillations or very slow decay.\\n\\n    # Ensure the integrand and limits are set up for Euler's segment summation\\n    euler_integrand = integrand\\n    euler_lower_limit = lower_limit\\n    euler_upper_limit = upper_limit\\n\\n    if euler_lower_limit == -np.inf: # This should mostly be handled by Step 2 or 3.\\n        # This case handles (-inf, b] if previous transformation failed.\\n        # Transform x to y = upper_limit - x, so dx = -dy\\n        # The integral becomes int_{inf}^{0} f(upper_limit - y) (-dy) which simplifies to int_{0}^{inf} f(upper_limit - y) dy\\n        def transformed_integrand_for_euler_neg_inf(y):\\n            return integrand(euler_upper_limit - y)\\n        \\n        euler_integrand = transformed_integrand_for_euler_neg_inf\\n        euler_lower_limit = 0.0 # New lower limit is finite\\n        euler_upper_limit = np.inf # New upper limit is infinite\\n\\n    # At this point, euler_lower_limit is guaranteed finite.\\n\\n    current_segment_start = float(euler_lower_limit)\\n    segment_length = math.pi  # A common heuristic segment length for oscillations\\n    \\n    segment_integrals = []\\n    \\n    max_segments_to_compute = 10000 \\n    min_segments_for_euler = 50 # Minimum terms for Euler acceleration to be effective\\n\\n    prev_seg_val = None\\n    consistent_sign_count = 0 # To detect non-alternating series\\n    \\n    # If the finite interval is very small, just try quad very aggressively one last time.\\n    if euler_upper_limit != np.inf and (euler_upper_limit - euler_lower_limit) < segment_length * 2: # Consider at least 2 segments worth\\n        try:\\n            answer, error_estimate = scipy.integrate.quad(\\n                euler_integrand, euler_lower_limit, euler_upper_limit,\\n                limit=200000, epsabs=1e-15, epsrel=1e-15\\n            )\\n            if (np.isnan(answer) or np.isinf(answer) or error_estimate > 1e-10):\\n                 raise ValueError(\\"Small finite interval quad failed even in Euler fallback.\\")\\n            return answer, error_estimate\\n        except Exception:\\n            return np.nan, np.inf # Indicate ultimate failure\\n\\n    for i in range(max_segments_to_compute):\\n        seg_start = current_segment_start\\n        seg_end = current_segment_start + segment_length\\n\\n        # Clamp seg_end to upper_limit if it's finite and exceeded\\n        if euler_upper_limit != np.inf and seg_end > euler_upper_limit:\\n            seg_end = euler_upper_limit\\n        \\n        # If this segment is too short or we've passed the upper limit\\n        if seg_end <= seg_start + 1e-12: # Add a small epsilon to ensure non-zero length\\n            break \\n\\n        try:\\n            # Use aggressive quad parameters for segment integration\\n            seg_val, seg_err = scipy.integrate.quad(\\n                euler_integrand, seg_start, seg_end,\\n                limit=10000, epsabs=1e-20, epsrel=1e-20 # Very tight epsilons for segments\\n            )\\n            \\n            # If segment integral fails to converge to a very small error, this whole method might be unsuitable.\\n            # Raise an error to be caught, leading to a sum of prior segments with high error.\\n            if np.isnan(seg_val) or np.isinf(seg_val) or seg_err > 1e-10: \\n                raise ValueError(f\\"Segment integration failed at {i}-th segment with val={seg_val}, err={seg_err}\\")\\n\\n            segment_integrals.append(seg_val)\\n            current_segment_start = seg_end # Move to the end of the current segment\\n\\n            # Early exit if we reached the finite upper_limit\\n            if euler_upper_limit != np.inf and current_segment_start >= euler_upper_limit - 1e-9: # Account for float precision\\n                break\\n\\n            # --- Checks for suitability of Euler transformation and early exit ---\\n            if i > 0:\\n                # Check for alternating signs (crucial for Euler's efficiency)\\n                # If terms consistently do not alternate, Euler transformation might not be suitable.\\n                if seg_val * prev_seg_val >= 0 and abs(seg_val) > 1e-18: # Lower magnitude threshold for sign check\\n                    consistent_sign_count += 1\\n                else:\\n                    consistent_sign_count = 0 # Reset if signs alternate\\n                \\n                # If signs consistently do not alternate after a few initial terms,\\n                # return sum of terms so far with high error.\\n                if consistent_sign_count >= 15 and i >= min_segments_for_euler: \\n                    return np.sum(segment_integrals), np.inf \\n\\n                # Check for rapid decay: if terms are consistently very small, implies convergence\\n                # This suggests the series has already largely converged without acceleration\\n                if abs(seg_val) < 1e-18: \\n                    # If the sum of recent terms is negligible compared to the total sum\\n                    if i >= min_segments_for_euler and abs(np.sum(segment_integrals[-10:])) < 1e-12: \\n                        break # Likely converged enough, no need for more segments/acceleration\\n\\n            prev_seg_val = seg_val\\n\\n        except Exception:\\n            # If any segment integration fails, return the sum of successfully collected segments\\n            # with a high error to indicate uncertainty.\\n            return np.sum(segment_integrals), np.inf\\n\\n    # After collecting segments, apply Euler acceleration if enough terms were gathered\\n    if len(segment_integrals) >= min_segments_for_euler:\\n        return _euler_accelerate_series(segment_integrals)\\n    else:\\n        # Not enough terms collected for Euler acceleration, return simple sum\\n        # with high uncertainty.\\n        return np.sum(segment_integrals), np.inf "
}`);
        const originalCode = codes["old_code"];
        const modifiedCode = codes["new_code"];
        const originalIndex = codes["old_index"];
        const modifiedIndex = codes["new_index"];

        function displaySideBySideDiff(originalText, modifiedText) {
          const diff = Diff.diffLines(originalText, modifiedText);

          let originalHtmlLines = [];
          let modifiedHtmlLines = [];

          const escapeHtml = (text) =>
            text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");

          diff.forEach((part) => {
            // Split the part's value into individual lines.
            // If the string ends with a newline, split will add an empty string at the end.
            // We need to filter this out unless it's an actual empty line in the code.
            const lines = part.value.split("\n");
            const actualContentLines =
              lines.length > 0 && lines[lines.length - 1] === "" ? lines.slice(0, -1) : lines;

            actualContentLines.forEach((lineContent) => {
              const escapedLineContent = escapeHtml(lineContent);

              if (part.removed) {
                // Line removed from original, display in original column, add blank in modified.
                originalHtmlLines.push(
                  `<span class="diff-line diff-removed">${escapedLineContent}</span>`,
                );
                // Use &nbsp; for consistent line height.
                modifiedHtmlLines.push(`<span class="diff-line">&nbsp;</span>`);
              } else if (part.added) {
                // Line added to modified, add blank in original column, display in modified.
                // Use &nbsp; for consistent line height.
                originalHtmlLines.push(`<span class="diff-line">&nbsp;</span>`);
                modifiedHtmlLines.push(
                  `<span class="diff-line diff-added">${escapedLineContent}</span>`,
                );
              } else {
                // Equal part - no special styling (no background)
                // Common line, display in both columns without any specific diff class.
                originalHtmlLines.push(`<span class="diff-line">${escapedLineContent}</span>`);
                modifiedHtmlLines.push(`<span class="diff-line">${escapedLineContent}</span>`);
              }
            });
          });

          // Join the lines and set innerHTML.
          originalDiffOutput.innerHTML = originalHtmlLines.join("");
          modifiedDiffOutput.innerHTML = modifiedHtmlLines.join("");
        }

        // Initial display with default content on DOMContentLoaded.
        displaySideBySideDiff(originalCode, modifiedCode);

        // Title the texts with their node numbers.
        originalTitle.textContent = `Parent #${originalIndex}`;
        modifiedTitle.textContent = `Child #${modifiedIndex}`;
      }

      // Load the jsdiff script when the DOM is fully loaded.
      document.addEventListener("DOMContentLoaded", loadJsDiff);
    </script>
  </body>
</html>
